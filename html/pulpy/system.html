<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pulpy.system API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pulpy.system</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import random
import simpy
import numpy as np
from collections import OrderedDict
from pulpy.fun import *
from pulpy.interfaces import *
from pulpy.alloc import AllocationMap


#utils
def build_job_catalog(catalog_size, max_item_work = 10):
    &#34;&#34;&#34;
    Initializes a catalog of potential jobs.
    Job catalog is the size of catalog_size
    Job names = {0, ...., catalog_size}
    Job work random int between (1, max_item_work)
    &#34;&#34;&#34;
    c = Catalog()
    c.items = [Job(f&#34;item_{name}&#34;, random.randint(1, max_item_work)) for name in range(catalog_size) ]
    return c

def build_catalog(catalog_size, max_item_work = 10, max_item_size = 10):
    &#34;&#34;&#34;
    Initializes a catalog of potential resource items.
    Catalog is the size of catalog_size.
    names = {0, ...., catalog_size}
    Item work random int between (1, max_item_work)
    Item size random int between (1, max_item_size)
    &#34;&#34;&#34;
    c = Catalog()
    c.items = [Item(f&#34;item_{name}&#34;, random.randint(1, max_item_work), random.randint(1, max_item_work)) for name in range(catalog_size) ]
    return c

class Context(object):
    &#34;&#34;&#34;
    Generic container for common instances rquired by other objects.
    Including:
        SimPy Environment (env)
        Monitor
        Catalog (Jobs of Resource Items)
    &#34;&#34;&#34;
    def __init__(self, env, monitor, catalog):
        self.env = env
        self.monitor = monitor
        self.catalog = catalog

class CoreRequestSource(object):
    &#34;&#34;&#34;
    Parent class of all Request Sources.
    generates and sends requests.
    &#34;&#34;&#34;
    def __init__(self, init_n = 0):
        self.n = init_n   # request counter

    def send_request(self, dst, request):
        request.start()
        dst.add_request(request)

    def generate_request(self, item):
        # simple impementation
        self.n += 1
        new_req = Request(self.env, self.n, item)
        return new_req

class RequestSource(CoreRequestSource):
    &#34;&#34;&#34;
    Sends requests according to given popularity map.
    &#34;&#34;&#34;
    def __init__(self,  init_n = 0, prob_map = None):
        super().__init__(init_n)
        self.prob_map = None
        if prob_map:
            self.update_probability_map(prob_map)
        self.next_batch = []

    def update_probability_map(self, prob_map):
        self.prob_map = prob_map
        self.catalog = prob_map.catalog
        self.catalog_weights = prob_map.get_all_probabilities(as_list=True)

    def generate_request(self):
        &#34;&#34;&#34;
        This function is used to generate tuples (request, firing_time).
        &#34;&#34;&#34;
        # just rewrite it to your convenience. Defaults to Poisson events
        # chosen accordingly to a probability map.
        if not self.prob_map:
            raise Exception(&#34;No probability map found, can&#39;t generate requests.&#34;)

        if not self.next_batch:
            batch_size = 1000
            r = random.choices(self.catalog.get(), self.catalog_weights, k=batch_size)
            dt = [random.expovariate(self.prob_map.intensity) for _ in range(batch_size)]
            # FIXME!!! what if theres no prob_map ?
            self.next_batch = list(zip(r,dt))

        item, delta_t  = self.next_batch.pop()
        new_req = super().generate_request(item)
        return (new_req, delta_t)

    def send_requests(self, dst):
        while True:
            new_request, delta_t = self.generate_request()
            yield self.env.timeout(delta_t)
            self.send_request(dst, new_request)


class Source(ContextUser, RequestSource):
    &#34;&#34;&#34;
     Creates and emits requests
     &#34;&#34;&#34;
    def __init__(self, context, init_n = 0, intensity = 10, weights = None):
        ContextUser.__init__(self, context)
        RequestSource.__init__(self, init_n = init_n)
        prob_map = ProbabilityMap(self.catalog)
        if not weights:
            prob_map.generate_weights()
        else:
            prob_map.allocate_weights(weights)
        prob_map.intensity = intensity
        self.update_probability_map(prob_map)


class Monitor(Observer, object):
    &#34;&#34;&#34;
    Observer Object used to monitor simulation.
    &#34;&#34;&#34;
    def __init__(self, env):
        self.env=env
        self.start_time=self.env.now

        self.errors=[]

        self.data = dict() # counters and data
        self.data_by_name = dict()
        self.ts = dict()   # time series

        self.last_print = 0
        self.print_every = 50

        self.max_log_length = 100
        self.head = 0

    def update(self, name, report):
        assert isinstance(report,Report)
        assert isinstance(report.value, dict)
        for k,v in report.value.items():
            if name not in self.data_by_name.keys():
                self.data_by_name[name] = dict()
            if k not in self.data_by_name[name].keys():
                self.data_by_name[name][k] = 0
            self.data_by_name[name][k] += v
            if k not in self.data.keys():
                self.data[k] = 0
            self.data[k] += v
        if self.env.now - self.last_print &gt; self.print_every:
            self.last_print       = self.env.now
            print(&#34;    ----------: &#34;, self.data, &#34;running time:&#34;, self.env.now)

    def updatets(self, report):
        assert isinstance(report,Report)
        assert isinstance(report.value, dict)
        for k,v in report.value.items():
            if k not in self.ts.keys():
                self.ts[k] = []
            self.ts[k].append(v)


class Report(Token):
    __slots__ = [&#34;id&#34;, &#34;type&#34;,&#34;value&#34;]
    def __init__(self, id, value ):
        assert isinstance(value, dict)
        self.value = value
        super().__init__(id, type = &#34;Report&#34;)

class Result(Token):
    __slots__ = [&#34;id&#34;, &#34;type&#34;, &#34;result&#34;, &#34;reason&#34;]
    def __init__(self, result, reason = None ):
        assert isinstance(result, int)
        self.result = result
        if result != 0:
            assert reason
            self.reason = reason
        super().__init__(id = None, type = &#34;Result&#34;)

    def __bool__(self):
        return self.result == 0

class Item(object):
    &#34;&#34;&#34;
    Object that can be requested by users.
    &#34;&#34;&#34;
    __slots__ = [&#34;name&#34;, &#34;work&#34;, &#34;size&#34;,&#34;life_cycle&#34;]
    def __init__(self, name, work, size):
        self.name = name
        self.work = work
        self.size = size
        self.life_cycle = 0
        # two lifecycles:
        #  0: first exhaust work, then transfer (default).
        #  1: simoultaneously consume work and transfer.

class Content(Item):
    &#34;&#34;&#34;
     Content object (file) that can be requested by users.
     &#34;&#34;&#34;
    def __init__(self, name, size):
        work = 0
        super().__init__(name, work, size)

class Job(Item):
    &#34;&#34;&#34;
    Task to be executed, requested by users.
    &#34;&#34;&#34;
    def __init__(self, name, work):
        size = 0
        super().__init__(name, work, size)

class Catalog(object):
    &#34;&#34;&#34;
     Catalog of all possible items.
     &#34;&#34;&#34;
    def __init__(self):
        self.items = list()

    def get_size(self):
        return len(self.items)

    def put(self, item):
        assert isinstance(item, Item)
        if item in self.items:
            return &#34;Item already in catalog&#34;
        self.items.append(item)

    def drop(self, item):
        if item not in self.items:
            return &#34;Item not in catalog&#34;
        self.items.remove(item)

    def get(self):
        return self.items

    def get_iterator(self):
        for i in self.items:
            yield i

    def get_map(self):
        for i in self.items:
            yield (i.name, i.work)

    def item_obj_from_name(self, item_name):

        for i in self.get():
            if i.name==item_name:
                return i
        else:
            raise ValueError (&#34;Item with name: &#34;, item_name, &#34; not in catalog.&#34;)

class Request(object):
    &#34;&#34;&#34;
    Request Object.
    Can be a request for Work or Space.
    &#34;&#34;&#34;
    _NOT_INIT = 0
    _STARTED = 1
    _FINISHED = 2
    _PAUSED = 3

    def __init__(self,env, n, item, cli_proc_rate = 10000, cli_bw = 10000, do_timestamp = False):
        assert isinstance(item, Item)
        self.env = env
        self.item = item  #an Item object

        self.state = Request._NOT_INIT

        self.remaining_work = item.work   # amount of work required to finish the requested task.
        self.cli_proc_rate = cli_proc_rate  # Client&#39;s processing rate or bandwith

        self.remaining_size = item.size   # amount of pending space transfer required to finish the requested task.
        self.cli_bw = cli_bw  # Client&#39;s processing rate or bandwith

        self.name = item.name
        self.n = n
        self.start_time = None
        self.do_timestamp = do_timestamp
        self.finish_callback = None    #update to do an action on request being finished

    def _process(self, target_resource, target_cap, delta_t, quota, wanted = None):
        if not wanted:
            wanted = min(target_cap*delta_t, target_resource)
        margin = quota - wanted
        if margin &gt; 0:
            # We didn&#39;t use that much
            target_resource = 0
        else:
            # we used all and could use a little extra
            target_resource -= quota
        return margin, target_resource

    def process(self, resource, delta_t, quota, wanted = None):
        # Resource must be one of &#34;work&#34; or &#34;space&#34;
        if resource == &#34;work&#34;:
            margin, self.remaining_work = self._process(self.remaining_work, self.cli_proc_rate, delta_t, quota, wanted)
        elif resource == &#34;space&#34;:
            margin, self.remaining_size = self._process(self.remaining_size, self.cli_bw, delta_t, quota, wanted)
        else:
            raise Exception(&#34;ProcessingError: Unknown resource.&#34;)

        if self.remaining_work &lt;= 0 and self.remaining_size &lt;=0:
            self.finish()
        return margin

    def _estimate_time(self, target_resource, target_cap, cap = None):
        div = target_cap
        if cap:
            div = min(div, cap)
        expected_time =  target_resource / div
        return expected_time

    def estimate_time_to_completition(self, proc_rate_cap = None):
        return self._estimate_time(self.remaining_work , self.cli_proc_rate, proc_rate_cap)

    def estimate_remaining_transfer_time(self, bw_cap = None):
        return self._estimate_time(self.remaining_size , self.cli_bw, bw_cap)

    def start(self):
        if self.state ==  Request._STARTED:
            return
        self.state = Request._STARTED
        if self.do_timestamp:
            self.start_time = self.env.now

    def finish(self):
        if self.state ==  Request._FINISHED:
            return
        self.state = Request._FINISHED
        if self.do_timestamp:
            self.finish_time = self.env.now
        if self.finish_callback:
            self.finish_callback()

    def update_finish_callback(f):
        self.finish_callback = f

    def is_alive(self):
        return self.state != self._FINISHED

    def may_process_size(self):
        if self.item.life_cycle == 1:
            return True
        if self.item.life_cycle == 0 and self.remaining_work &lt;= 0:
            return True
        return False




class ProbabilityMap(object):
    &#34;&#34;&#34;
     This object augments a catalog by adding popularities.
     &#34;&#34;&#34;
    def __init__(self, catalog):
        self.catalog = catalog
        self.map = OrderedDict()
        self.intensity = 1
        self.np_popularity = None

    def __iter__(self):
        return self.map.__iter__()

    def generate_weights(self, method = &#34;uniform&#34;):
        if method == &#34;uniform&#34;:
            w = [random.random() for _ in range(self.catalog.get_size())]
            w = sorted( [i/sum(w) for i in w  ] )[::-1]
        elif method == &#34;equal&#34;:
            w = [1/l for _ in range(self.catalog.get_size())]
        self.allocate_weights(w)

    def allocate_weights(self, weights):
        # Note: weights must be non increasing, non-negative values

        if isinstance(weights, list):
            keys = self.catalog.get()
            wnp = np.array(weights)

        elif isinstance(weights, np.ndarray):
            keys = self.catalog.get()
            wnp = weights

        elif isinstance(weights, dict ):
            lt = sorted(weights.items(), key = lambda v: -v[1])  #list of tuples
            self.map = OrderedDict(lt)   #recall that zip will result in the min length
            keys = self.map.keys()
            wnp = np.array(list(self.map.values()))

        else:
            raise Exception(&#34;Inknown popularity format.&#34;)

        if len(wnp.shape) != 1:
            raise Exception(&#34;Bad probability vector dimensions.&#34;)

        if min(wnp) &lt; 0:
            raise Exception(&#34;Bad probability vector contains negative value.&#34;)

        if (len(wnp)&gt;1): # Incase we only have one item that has already been requested
            if min(np.diff(wnp)) &gt; 0:
                raise Exception(&#34;Bad probability vector contains some strictly increasing values.&#34;)

        self.intensity = wnp.sum()
        wnp = wnp / self.intensity   # normalize

        self.map = OrderedDict( zip(keys, wnp))   #recall that zip will result in the min length
        self.np_popularity = wnp

    def get_pop(self, item):
        return self.map[item]

    def get_intensity(self):
        return self.intensity

    def get_map(self):
        return self.map

    def get_pop_array(self):
        return self.np_popularity

    def get_all_probabilities(self, as_list=False):
        if as_list:
            return list(self.map.values())
        else:
            return self.map.values()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pulpy.system.build_catalog"><code class="name flex">
<span>def <span class="ident">build_catalog</span></span>(<span>catalog_size, max_item_work=10, max_item_size=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Initializes a catalog of potential resource items.
Catalog is the size of catalog_size.
names = {0, ...., catalog_size}
Item work random int between (1, max_item_work)
Item size random int between (1, max_item_size)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_catalog(catalog_size, max_item_work = 10, max_item_size = 10):
    &#34;&#34;&#34;
    Initializes a catalog of potential resource items.
    Catalog is the size of catalog_size.
    names = {0, ...., catalog_size}
    Item work random int between (1, max_item_work)
    Item size random int between (1, max_item_size)
    &#34;&#34;&#34;
    c = Catalog()
    c.items = [Item(f&#34;item_{name}&#34;, random.randint(1, max_item_work), random.randint(1, max_item_work)) for name in range(catalog_size) ]
    return c</code></pre>
</details>
</dd>
<dt id="pulpy.system.build_job_catalog"><code class="name flex">
<span>def <span class="ident">build_job_catalog</span></span>(<span>catalog_size, max_item_work=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Initializes a catalog of potential jobs.
Job catalog is the size of catalog_size
Job names = {0, ...., catalog_size}
Job work random int between (1, max_item_work)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_job_catalog(catalog_size, max_item_work = 10):
    &#34;&#34;&#34;
    Initializes a catalog of potential jobs.
    Job catalog is the size of catalog_size
    Job names = {0, ...., catalog_size}
    Job work random int between (1, max_item_work)
    &#34;&#34;&#34;
    c = Catalog()
    c.items = [Job(f&#34;item_{name}&#34;, random.randint(1, max_item_work)) for name in range(catalog_size) ]
    return c</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pulpy.system.Catalog"><code class="flex name class">
<span>class <span class="ident">Catalog</span></span>
</code></dt>
<dd>
<div class="desc"><p>Catalog of all possible items.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Catalog(object):
    &#34;&#34;&#34;
     Catalog of all possible items.
     &#34;&#34;&#34;
    def __init__(self):
        self.items = list()

    def get_size(self):
        return len(self.items)

    def put(self, item):
        assert isinstance(item, Item)
        if item in self.items:
            return &#34;Item already in catalog&#34;
        self.items.append(item)

    def drop(self, item):
        if item not in self.items:
            return &#34;Item not in catalog&#34;
        self.items.remove(item)

    def get(self):
        return self.items

    def get_iterator(self):
        for i in self.items:
            yield i

    def get_map(self):
        for i in self.items:
            yield (i.name, i.work)

    def item_obj_from_name(self, item_name):

        for i in self.get():
            if i.name==item_name:
                return i
        else:
            raise ValueError (&#34;Item with name: &#34;, item_name, &#34; not in catalog.&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pulpy.system.Catalog.drop"><code class="name flex">
<span>def <span class="ident">drop</span></span>(<span>self, item)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drop(self, item):
    if item not in self.items:
        return &#34;Item not in catalog&#34;
    self.items.remove(item)</code></pre>
</details>
</dd>
<dt id="pulpy.system.Catalog.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self):
    return self.items</code></pre>
</details>
</dd>
<dt id="pulpy.system.Catalog.get_iterator"><code class="name flex">
<span>def <span class="ident">get_iterator</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_iterator(self):
    for i in self.items:
        yield i</code></pre>
</details>
</dd>
<dt id="pulpy.system.Catalog.get_map"><code class="name flex">
<span>def <span class="ident">get_map</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_map(self):
    for i in self.items:
        yield (i.name, i.work)</code></pre>
</details>
</dd>
<dt id="pulpy.system.Catalog.get_size"><code class="name flex">
<span>def <span class="ident">get_size</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_size(self):
    return len(self.items)</code></pre>
</details>
</dd>
<dt id="pulpy.system.Catalog.item_obj_from_name"><code class="name flex">
<span>def <span class="ident">item_obj_from_name</span></span>(<span>self, item_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def item_obj_from_name(self, item_name):

    for i in self.get():
        if i.name==item_name:
            return i
    else:
        raise ValueError (&#34;Item with name: &#34;, item_name, &#34; not in catalog.&#34;)</code></pre>
</details>
</dd>
<dt id="pulpy.system.Catalog.put"><code class="name flex">
<span>def <span class="ident">put</span></span>(<span>self, item)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put(self, item):
    assert isinstance(item, Item)
    if item in self.items:
        return &#34;Item already in catalog&#34;
    self.items.append(item)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pulpy.system.Content"><code class="flex name class">
<span>class <span class="ident">Content</span></span>
<span>(</span><span>name, size)</span>
</code></dt>
<dd>
<div class="desc"><p>Content object (file) that can be requested by users.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Content(Item):
    &#34;&#34;&#34;
     Content object (file) that can be requested by users.
     &#34;&#34;&#34;
    def __init__(self, name, size):
        work = 0
        super().__init__(name, work, size)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pulpy.system.Item" href="#pulpy.system.Item">Item</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pulpy.system.Item" href="#pulpy.system.Item">Item</a></b></code>:
<ul class="hlist">
<li><code><a title="pulpy.system.Item.life_cycle" href="#pulpy.system.Item.life_cycle">life_cycle</a></code></li>
<li><code><a title="pulpy.system.Item.name" href="#pulpy.system.Item.name">name</a></code></li>
<li><code><a title="pulpy.system.Item.size" href="#pulpy.system.Item.size">size</a></code></li>
<li><code><a title="pulpy.system.Item.work" href="#pulpy.system.Item.work">work</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pulpy.system.Context"><code class="flex name class">
<span>class <span class="ident">Context</span></span>
<span>(</span><span>env, monitor, catalog)</span>
</code></dt>
<dd>
<div class="desc"><p>Generic container for common instances rquired by other objects.</p>
<h2 id="including">Including</h2>
<p>SimPy Environment (env)
Monitor
Catalog (Jobs of Resource Items)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Context(object):
    &#34;&#34;&#34;
    Generic container for common instances rquired by other objects.
    Including:
        SimPy Environment (env)
        Monitor
        Catalog (Jobs of Resource Items)
    &#34;&#34;&#34;
    def __init__(self, env, monitor, catalog):
        self.env = env
        self.monitor = monitor
        self.catalog = catalog</code></pre>
</details>
</dd>
<dt id="pulpy.system.CoreRequestSource"><code class="flex name class">
<span>class <span class="ident">CoreRequestSource</span></span>
<span>(</span><span>init_n=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Parent class of all Request Sources.
generates and sends requests.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CoreRequestSource(object):
    &#34;&#34;&#34;
    Parent class of all Request Sources.
    generates and sends requests.
    &#34;&#34;&#34;
    def __init__(self, init_n = 0):
        self.n = init_n   # request counter

    def send_request(self, dst, request):
        request.start()
        dst.add_request(request)

    def generate_request(self, item):
        # simple impementation
        self.n += 1
        new_req = Request(self.env, self.n, item)
        return new_req</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pulpy.machines.CoreMachine" href="machines.html#pulpy.machines.CoreMachine">CoreMachine</a></li>
<li><a title="pulpy.system.RequestSource" href="#pulpy.system.RequestSource">RequestSource</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pulpy.system.CoreRequestSource.generate_request"><code class="name flex">
<span>def <span class="ident">generate_request</span></span>(<span>self, item)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_request(self, item):
    # simple impementation
    self.n += 1
    new_req = Request(self.env, self.n, item)
    return new_req</code></pre>
</details>
</dd>
<dt id="pulpy.system.CoreRequestSource.send_request"><code class="name flex">
<span>def <span class="ident">send_request</span></span>(<span>self, dst, request)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_request(self, dst, request):
    request.start()
    dst.add_request(request)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pulpy.system.Item"><code class="flex name class">
<span>class <span class="ident">Item</span></span>
<span>(</span><span>name, work, size)</span>
</code></dt>
<dd>
<div class="desc"><p>Object that can be requested by users.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Item(object):
    &#34;&#34;&#34;
    Object that can be requested by users.
    &#34;&#34;&#34;
    __slots__ = [&#34;name&#34;, &#34;work&#34;, &#34;size&#34;,&#34;life_cycle&#34;]
    def __init__(self, name, work, size):
        self.name = name
        self.work = work
        self.size = size
        self.life_cycle = 0
        # two lifecycles:
        #  0: first exhaust work, then transfer (default).
        #  1: simoultaneously consume work and transfer.</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pulpy.system.Content" href="#pulpy.system.Content">Content</a></li>
<li><a title="pulpy.system.Job" href="#pulpy.system.Job">Job</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pulpy.system.Item.life_cycle"><code class="name">var <span class="ident">life_cycle</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="pulpy.system.Item.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="pulpy.system.Item.size"><code class="name">var <span class="ident">size</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="pulpy.system.Item.work"><code class="name">var <span class="ident">work</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
</dl>
</dd>
<dt id="pulpy.system.Job"><code class="flex name class">
<span>class <span class="ident">Job</span></span>
<span>(</span><span>name, work)</span>
</code></dt>
<dd>
<div class="desc"><p>Task to be executed, requested by users.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Job(Item):
    &#34;&#34;&#34;
    Task to be executed, requested by users.
    &#34;&#34;&#34;
    def __init__(self, name, work):
        size = 0
        super().__init__(name, work, size)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pulpy.system.Item" href="#pulpy.system.Item">Item</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pulpy.system.Item" href="#pulpy.system.Item">Item</a></b></code>:
<ul class="hlist">
<li><code><a title="pulpy.system.Item.life_cycle" href="#pulpy.system.Item.life_cycle">life_cycle</a></code></li>
<li><code><a title="pulpy.system.Item.name" href="#pulpy.system.Item.name">name</a></code></li>
<li><code><a title="pulpy.system.Item.size" href="#pulpy.system.Item.size">size</a></code></li>
<li><code><a title="pulpy.system.Item.work" href="#pulpy.system.Item.work">work</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pulpy.system.Monitor"><code class="flex name class">
<span>class <span class="ident">Monitor</span></span>
<span>(</span><span>env)</span>
</code></dt>
<dd>
<div class="desc"><p>Observer Object used to monitor simulation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Monitor(Observer, object):
    &#34;&#34;&#34;
    Observer Object used to monitor simulation.
    &#34;&#34;&#34;
    def __init__(self, env):
        self.env=env
        self.start_time=self.env.now

        self.errors=[]

        self.data = dict() # counters and data
        self.data_by_name = dict()
        self.ts = dict()   # time series

        self.last_print = 0
        self.print_every = 50

        self.max_log_length = 100
        self.head = 0

    def update(self, name, report):
        assert isinstance(report,Report)
        assert isinstance(report.value, dict)
        for k,v in report.value.items():
            if name not in self.data_by_name.keys():
                self.data_by_name[name] = dict()
            if k not in self.data_by_name[name].keys():
                self.data_by_name[name][k] = 0
            self.data_by_name[name][k] += v
            if k not in self.data.keys():
                self.data[k] = 0
            self.data[k] += v
        if self.env.now - self.last_print &gt; self.print_every:
            self.last_print       = self.env.now
            print(&#34;    ----------: &#34;, self.data, &#34;running time:&#34;, self.env.now)

    def updatets(self, report):
        assert isinstance(report,Report)
        assert isinstance(report.value, dict)
        for k,v in report.value.items():
            if k not in self.ts.keys():
                self.ts[k] = []
            self.ts[k].append(v)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pulpy.interfaces.Observer" href="interfaces.html#pulpy.interfaces.Observer">Observer</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pulpy.system.Monitor.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, name, report)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, name, report):
    assert isinstance(report,Report)
    assert isinstance(report.value, dict)
    for k,v in report.value.items():
        if name not in self.data_by_name.keys():
            self.data_by_name[name] = dict()
        if k not in self.data_by_name[name].keys():
            self.data_by_name[name][k] = 0
        self.data_by_name[name][k] += v
        if k not in self.data.keys():
            self.data[k] = 0
        self.data[k] += v
    if self.env.now - self.last_print &gt; self.print_every:
        self.last_print       = self.env.now
        print(&#34;    ----------: &#34;, self.data, &#34;running time:&#34;, self.env.now)</code></pre>
</details>
</dd>
<dt id="pulpy.system.Monitor.updatets"><code class="name flex">
<span>def <span class="ident">updatets</span></span>(<span>self, report)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def updatets(self, report):
    assert isinstance(report,Report)
    assert isinstance(report.value, dict)
    for k,v in report.value.items():
        if k not in self.ts.keys():
            self.ts[k] = []
        self.ts[k].append(v)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pulpy.system.ProbabilityMap"><code class="flex name class">
<span>class <span class="ident">ProbabilityMap</span></span>
<span>(</span><span>catalog)</span>
</code></dt>
<dd>
<div class="desc"><p>This object augments a catalog by adding popularities.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProbabilityMap(object):
    &#34;&#34;&#34;
     This object augments a catalog by adding popularities.
     &#34;&#34;&#34;
    def __init__(self, catalog):
        self.catalog = catalog
        self.map = OrderedDict()
        self.intensity = 1
        self.np_popularity = None

    def __iter__(self):
        return self.map.__iter__()

    def generate_weights(self, method = &#34;uniform&#34;):
        if method == &#34;uniform&#34;:
            w = [random.random() for _ in range(self.catalog.get_size())]
            w = sorted( [i/sum(w) for i in w  ] )[::-1]
        elif method == &#34;equal&#34;:
            w = [1/l for _ in range(self.catalog.get_size())]
        self.allocate_weights(w)

    def allocate_weights(self, weights):
        # Note: weights must be non increasing, non-negative values

        if isinstance(weights, list):
            keys = self.catalog.get()
            wnp = np.array(weights)

        elif isinstance(weights, np.ndarray):
            keys = self.catalog.get()
            wnp = weights

        elif isinstance(weights, dict ):
            lt = sorted(weights.items(), key = lambda v: -v[1])  #list of tuples
            self.map = OrderedDict(lt)   #recall that zip will result in the min length
            keys = self.map.keys()
            wnp = np.array(list(self.map.values()))

        else:
            raise Exception(&#34;Inknown popularity format.&#34;)

        if len(wnp.shape) != 1:
            raise Exception(&#34;Bad probability vector dimensions.&#34;)

        if min(wnp) &lt; 0:
            raise Exception(&#34;Bad probability vector contains negative value.&#34;)

        if (len(wnp)&gt;1): # Incase we only have one item that has already been requested
            if min(np.diff(wnp)) &gt; 0:
                raise Exception(&#34;Bad probability vector contains some strictly increasing values.&#34;)

        self.intensity = wnp.sum()
        wnp = wnp / self.intensity   # normalize

        self.map = OrderedDict( zip(keys, wnp))   #recall that zip will result in the min length
        self.np_popularity = wnp

    def get_pop(self, item):
        return self.map[item]

    def get_intensity(self):
        return self.intensity

    def get_map(self):
        return self.map

    def get_pop_array(self):
        return self.np_popularity

    def get_all_probabilities(self, as_list=False):
        if as_list:
            return list(self.map.values())
        else:
            return self.map.values()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pulpy.system.ProbabilityMap.allocate_weights"><code class="name flex">
<span>def <span class="ident">allocate_weights</span></span>(<span>self, weights)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def allocate_weights(self, weights):
    # Note: weights must be non increasing, non-negative values

    if isinstance(weights, list):
        keys = self.catalog.get()
        wnp = np.array(weights)

    elif isinstance(weights, np.ndarray):
        keys = self.catalog.get()
        wnp = weights

    elif isinstance(weights, dict ):
        lt = sorted(weights.items(), key = lambda v: -v[1])  #list of tuples
        self.map = OrderedDict(lt)   #recall that zip will result in the min length
        keys = self.map.keys()
        wnp = np.array(list(self.map.values()))

    else:
        raise Exception(&#34;Inknown popularity format.&#34;)

    if len(wnp.shape) != 1:
        raise Exception(&#34;Bad probability vector dimensions.&#34;)

    if min(wnp) &lt; 0:
        raise Exception(&#34;Bad probability vector contains negative value.&#34;)

    if (len(wnp)&gt;1): # Incase we only have one item that has already been requested
        if min(np.diff(wnp)) &gt; 0:
            raise Exception(&#34;Bad probability vector contains some strictly increasing values.&#34;)

    self.intensity = wnp.sum()
    wnp = wnp / self.intensity   # normalize

    self.map = OrderedDict( zip(keys, wnp))   #recall that zip will result in the min length
    self.np_popularity = wnp</code></pre>
</details>
</dd>
<dt id="pulpy.system.ProbabilityMap.generate_weights"><code class="name flex">
<span>def <span class="ident">generate_weights</span></span>(<span>self, method='uniform')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_weights(self, method = &#34;uniform&#34;):
    if method == &#34;uniform&#34;:
        w = [random.random() for _ in range(self.catalog.get_size())]
        w = sorted( [i/sum(w) for i in w  ] )[::-1]
    elif method == &#34;equal&#34;:
        w = [1/l for _ in range(self.catalog.get_size())]
    self.allocate_weights(w)</code></pre>
</details>
</dd>
<dt id="pulpy.system.ProbabilityMap.get_all_probabilities"><code class="name flex">
<span>def <span class="ident">get_all_probabilities</span></span>(<span>self, as_list=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_probabilities(self, as_list=False):
    if as_list:
        return list(self.map.values())
    else:
        return self.map.values()</code></pre>
</details>
</dd>
<dt id="pulpy.system.ProbabilityMap.get_intensity"><code class="name flex">
<span>def <span class="ident">get_intensity</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_intensity(self):
    return self.intensity</code></pre>
</details>
</dd>
<dt id="pulpy.system.ProbabilityMap.get_map"><code class="name flex">
<span>def <span class="ident">get_map</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_map(self):
    return self.map</code></pre>
</details>
</dd>
<dt id="pulpy.system.ProbabilityMap.get_pop"><code class="name flex">
<span>def <span class="ident">get_pop</span></span>(<span>self, item)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pop(self, item):
    return self.map[item]</code></pre>
</details>
</dd>
<dt id="pulpy.system.ProbabilityMap.get_pop_array"><code class="name flex">
<span>def <span class="ident">get_pop_array</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pop_array(self):
    return self.np_popularity</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pulpy.system.Report"><code class="flex name class">
<span>class <span class="ident">Report</span></span>
<span>(</span><span>id, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Report(Token):
    __slots__ = [&#34;id&#34;, &#34;type&#34;,&#34;value&#34;]
    def __init__(self, id, value ):
        assert isinstance(value, dict)
        self.value = value
        super().__init__(id, type = &#34;Report&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pulpy.interfaces.Token" href="interfaces.html#pulpy.interfaces.Token">Token</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pulpy.system.Report.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pulpy.interfaces.Token" href="interfaces.html#pulpy.interfaces.Token">Token</a></b></code>:
<ul class="hlist">
<li><code><a title="pulpy.interfaces.Token.id" href="interfaces.html#pulpy.interfaces.Token.id">id</a></code></li>
<li><code><a title="pulpy.interfaces.Token.type" href="interfaces.html#pulpy.interfaces.Token.type">type</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pulpy.system.Request"><code class="flex name class">
<span>class <span class="ident">Request</span></span>
<span>(</span><span>env, n, item, cli_proc_rate=10000, cli_bw=10000, do_timestamp=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Request Object.
Can be a request for Work or Space.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Request(object):
    &#34;&#34;&#34;
    Request Object.
    Can be a request for Work or Space.
    &#34;&#34;&#34;
    _NOT_INIT = 0
    _STARTED = 1
    _FINISHED = 2
    _PAUSED = 3

    def __init__(self,env, n, item, cli_proc_rate = 10000, cli_bw = 10000, do_timestamp = False):
        assert isinstance(item, Item)
        self.env = env
        self.item = item  #an Item object

        self.state = Request._NOT_INIT

        self.remaining_work = item.work   # amount of work required to finish the requested task.
        self.cli_proc_rate = cli_proc_rate  # Client&#39;s processing rate or bandwith

        self.remaining_size = item.size   # amount of pending space transfer required to finish the requested task.
        self.cli_bw = cli_bw  # Client&#39;s processing rate or bandwith

        self.name = item.name
        self.n = n
        self.start_time = None
        self.do_timestamp = do_timestamp
        self.finish_callback = None    #update to do an action on request being finished

    def _process(self, target_resource, target_cap, delta_t, quota, wanted = None):
        if not wanted:
            wanted = min(target_cap*delta_t, target_resource)
        margin = quota - wanted
        if margin &gt; 0:
            # We didn&#39;t use that much
            target_resource = 0
        else:
            # we used all and could use a little extra
            target_resource -= quota
        return margin, target_resource

    def process(self, resource, delta_t, quota, wanted = None):
        # Resource must be one of &#34;work&#34; or &#34;space&#34;
        if resource == &#34;work&#34;:
            margin, self.remaining_work = self._process(self.remaining_work, self.cli_proc_rate, delta_t, quota, wanted)
        elif resource == &#34;space&#34;:
            margin, self.remaining_size = self._process(self.remaining_size, self.cli_bw, delta_t, quota, wanted)
        else:
            raise Exception(&#34;ProcessingError: Unknown resource.&#34;)

        if self.remaining_work &lt;= 0 and self.remaining_size &lt;=0:
            self.finish()
        return margin

    def _estimate_time(self, target_resource, target_cap, cap = None):
        div = target_cap
        if cap:
            div = min(div, cap)
        expected_time =  target_resource / div
        return expected_time

    def estimate_time_to_completition(self, proc_rate_cap = None):
        return self._estimate_time(self.remaining_work , self.cli_proc_rate, proc_rate_cap)

    def estimate_remaining_transfer_time(self, bw_cap = None):
        return self._estimate_time(self.remaining_size , self.cli_bw, bw_cap)

    def start(self):
        if self.state ==  Request._STARTED:
            return
        self.state = Request._STARTED
        if self.do_timestamp:
            self.start_time = self.env.now

    def finish(self):
        if self.state ==  Request._FINISHED:
            return
        self.state = Request._FINISHED
        if self.do_timestamp:
            self.finish_time = self.env.now
        if self.finish_callback:
            self.finish_callback()

    def update_finish_callback(f):
        self.finish_callback = f

    def is_alive(self):
        return self.state != self._FINISHED

    def may_process_size(self):
        if self.item.life_cycle == 1:
            return True
        if self.item.life_cycle == 0 and self.remaining_work &lt;= 0:
            return True
        return False</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pulpy.system.Request.estimate_remaining_transfer_time"><code class="name flex">
<span>def <span class="ident">estimate_remaining_transfer_time</span></span>(<span>self, bw_cap=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def estimate_remaining_transfer_time(self, bw_cap = None):
    return self._estimate_time(self.remaining_size , self.cli_bw, bw_cap)</code></pre>
</details>
</dd>
<dt id="pulpy.system.Request.estimate_time_to_completition"><code class="name flex">
<span>def <span class="ident">estimate_time_to_completition</span></span>(<span>self, proc_rate_cap=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def estimate_time_to_completition(self, proc_rate_cap = None):
    return self._estimate_time(self.remaining_work , self.cli_proc_rate, proc_rate_cap)</code></pre>
</details>
</dd>
<dt id="pulpy.system.Request.finish"><code class="name flex">
<span>def <span class="ident">finish</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def finish(self):
    if self.state ==  Request._FINISHED:
        return
    self.state = Request._FINISHED
    if self.do_timestamp:
        self.finish_time = self.env.now
    if self.finish_callback:
        self.finish_callback()</code></pre>
</details>
</dd>
<dt id="pulpy.system.Request.is_alive"><code class="name flex">
<span>def <span class="ident">is_alive</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_alive(self):
    return self.state != self._FINISHED</code></pre>
</details>
</dd>
<dt id="pulpy.system.Request.may_process_size"><code class="name flex">
<span>def <span class="ident">may_process_size</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def may_process_size(self):
    if self.item.life_cycle == 1:
        return True
    if self.item.life_cycle == 0 and self.remaining_work &lt;= 0:
        return True
    return False</code></pre>
</details>
</dd>
<dt id="pulpy.system.Request.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self, resource, delta_t, quota, wanted=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self, resource, delta_t, quota, wanted = None):
    # Resource must be one of &#34;work&#34; or &#34;space&#34;
    if resource == &#34;work&#34;:
        margin, self.remaining_work = self._process(self.remaining_work, self.cli_proc_rate, delta_t, quota, wanted)
    elif resource == &#34;space&#34;:
        margin, self.remaining_size = self._process(self.remaining_size, self.cli_bw, delta_t, quota, wanted)
    else:
        raise Exception(&#34;ProcessingError: Unknown resource.&#34;)

    if self.remaining_work &lt;= 0 and self.remaining_size &lt;=0:
        self.finish()
    return margin</code></pre>
</details>
</dd>
<dt id="pulpy.system.Request.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self):
    if self.state ==  Request._STARTED:
        return
    self.state = Request._STARTED
    if self.do_timestamp:
        self.start_time = self.env.now</code></pre>
</details>
</dd>
<dt id="pulpy.system.Request.update_finish_callback"><code class="name flex">
<span>def <span class="ident">update_finish_callback</span></span>(<span>f)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_finish_callback(f):
    self.finish_callback = f</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pulpy.system.RequestSource"><code class="flex name class">
<span>class <span class="ident">RequestSource</span></span>
<span>(</span><span>init_n=0, prob_map=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Sends requests according to given popularity map.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RequestSource(CoreRequestSource):
    &#34;&#34;&#34;
    Sends requests according to given popularity map.
    &#34;&#34;&#34;
    def __init__(self,  init_n = 0, prob_map = None):
        super().__init__(init_n)
        self.prob_map = None
        if prob_map:
            self.update_probability_map(prob_map)
        self.next_batch = []

    def update_probability_map(self, prob_map):
        self.prob_map = prob_map
        self.catalog = prob_map.catalog
        self.catalog_weights = prob_map.get_all_probabilities(as_list=True)

    def generate_request(self):
        &#34;&#34;&#34;
        This function is used to generate tuples (request, firing_time).
        &#34;&#34;&#34;
        # just rewrite it to your convenience. Defaults to Poisson events
        # chosen accordingly to a probability map.
        if not self.prob_map:
            raise Exception(&#34;No probability map found, can&#39;t generate requests.&#34;)

        if not self.next_batch:
            batch_size = 1000
            r = random.choices(self.catalog.get(), self.catalog_weights, k=batch_size)
            dt = [random.expovariate(self.prob_map.intensity) for _ in range(batch_size)]
            # FIXME!!! what if theres no prob_map ?
            self.next_batch = list(zip(r,dt))

        item, delta_t  = self.next_batch.pop()
        new_req = super().generate_request(item)
        return (new_req, delta_t)

    def send_requests(self, dst):
        while True:
            new_request, delta_t = self.generate_request()
            yield self.env.timeout(delta_t)
            self.send_request(dst, new_request)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pulpy.system.CoreRequestSource" href="#pulpy.system.CoreRequestSource">CoreRequestSource</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pulpy.system.Source" href="#pulpy.system.Source">Source</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pulpy.system.RequestSource.generate_request"><code class="name flex">
<span>def <span class="ident">generate_request</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is used to generate tuples (request, firing_time).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_request(self):
    &#34;&#34;&#34;
    This function is used to generate tuples (request, firing_time).
    &#34;&#34;&#34;
    # just rewrite it to your convenience. Defaults to Poisson events
    # chosen accordingly to a probability map.
    if not self.prob_map:
        raise Exception(&#34;No probability map found, can&#39;t generate requests.&#34;)

    if not self.next_batch:
        batch_size = 1000
        r = random.choices(self.catalog.get(), self.catalog_weights, k=batch_size)
        dt = [random.expovariate(self.prob_map.intensity) for _ in range(batch_size)]
        # FIXME!!! what if theres no prob_map ?
        self.next_batch = list(zip(r,dt))

    item, delta_t  = self.next_batch.pop()
    new_req = super().generate_request(item)
    return (new_req, delta_t)</code></pre>
</details>
</dd>
<dt id="pulpy.system.RequestSource.send_requests"><code class="name flex">
<span>def <span class="ident">send_requests</span></span>(<span>self, dst)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_requests(self, dst):
    while True:
        new_request, delta_t = self.generate_request()
        yield self.env.timeout(delta_t)
        self.send_request(dst, new_request)</code></pre>
</details>
</dd>
<dt id="pulpy.system.RequestSource.update_probability_map"><code class="name flex">
<span>def <span class="ident">update_probability_map</span></span>(<span>self, prob_map)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_probability_map(self, prob_map):
    self.prob_map = prob_map
    self.catalog = prob_map.catalog
    self.catalog_weights = prob_map.get_all_probabilities(as_list=True)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pulpy.system.Result"><code class="flex name class">
<span>class <span class="ident">Result</span></span>
<span>(</span><span>result, reason=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Result(Token):
    __slots__ = [&#34;id&#34;, &#34;type&#34;, &#34;result&#34;, &#34;reason&#34;]
    def __init__(self, result, reason = None ):
        assert isinstance(result, int)
        self.result = result
        if result != 0:
            assert reason
            self.reason = reason
        super().__init__(id = None, type = &#34;Result&#34;)

    def __bool__(self):
        return self.result == 0</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pulpy.interfaces.Token" href="interfaces.html#pulpy.interfaces.Token">Token</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pulpy.system.Result.reason"><code class="name">var <span class="ident">reason</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="pulpy.system.Result.result"><code class="name">var <span class="ident">result</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pulpy.interfaces.Token" href="interfaces.html#pulpy.interfaces.Token">Token</a></b></code>:
<ul class="hlist">
<li><code><a title="pulpy.interfaces.Token.id" href="interfaces.html#pulpy.interfaces.Token.id">id</a></code></li>
<li><code><a title="pulpy.interfaces.Token.type" href="interfaces.html#pulpy.interfaces.Token.type">type</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pulpy.system.Source"><code class="flex name class">
<span>class <span class="ident">Source</span></span>
<span>(</span><span>context, init_n=0, intensity=10, weights=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and emits requests</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Source(ContextUser, RequestSource):
    &#34;&#34;&#34;
     Creates and emits requests
     &#34;&#34;&#34;
    def __init__(self, context, init_n = 0, intensity = 10, weights = None):
        ContextUser.__init__(self, context)
        RequestSource.__init__(self, init_n = init_n)
        prob_map = ProbabilityMap(self.catalog)
        if not weights:
            prob_map.generate_weights()
        else:
            prob_map.allocate_weights(weights)
        prob_map.intensity = intensity
        self.update_probability_map(prob_map)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pulpy.interfaces.ContextUser" href="interfaces.html#pulpy.interfaces.ContextUser">ContextUser</a></li>
<li><a title="pulpy.system.RequestSource" href="#pulpy.system.RequestSource">RequestSource</a></li>
<li><a title="pulpy.system.CoreRequestSource" href="#pulpy.system.CoreRequestSource">CoreRequestSource</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pulpy.system.RequestSource" href="#pulpy.system.RequestSource">RequestSource</a></b></code>:
<ul class="hlist">
<li><code><a title="pulpy.system.RequestSource.generate_request" href="#pulpy.system.RequestSource.generate_request">generate_request</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pulpy" href="index.html">pulpy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pulpy.system.build_catalog" href="#pulpy.system.build_catalog">build_catalog</a></code></li>
<li><code><a title="pulpy.system.build_job_catalog" href="#pulpy.system.build_job_catalog">build_job_catalog</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pulpy.system.Catalog" href="#pulpy.system.Catalog">Catalog</a></code></h4>
<ul class="two-column">
<li><code><a title="pulpy.system.Catalog.drop" href="#pulpy.system.Catalog.drop">drop</a></code></li>
<li><code><a title="pulpy.system.Catalog.get" href="#pulpy.system.Catalog.get">get</a></code></li>
<li><code><a title="pulpy.system.Catalog.get_iterator" href="#pulpy.system.Catalog.get_iterator">get_iterator</a></code></li>
<li><code><a title="pulpy.system.Catalog.get_map" href="#pulpy.system.Catalog.get_map">get_map</a></code></li>
<li><code><a title="pulpy.system.Catalog.get_size" href="#pulpy.system.Catalog.get_size">get_size</a></code></li>
<li><code><a title="pulpy.system.Catalog.item_obj_from_name" href="#pulpy.system.Catalog.item_obj_from_name">item_obj_from_name</a></code></li>
<li><code><a title="pulpy.system.Catalog.put" href="#pulpy.system.Catalog.put">put</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pulpy.system.Content" href="#pulpy.system.Content">Content</a></code></h4>
</li>
<li>
<h4><code><a title="pulpy.system.Context" href="#pulpy.system.Context">Context</a></code></h4>
</li>
<li>
<h4><code><a title="pulpy.system.CoreRequestSource" href="#pulpy.system.CoreRequestSource">CoreRequestSource</a></code></h4>
<ul class="">
<li><code><a title="pulpy.system.CoreRequestSource.generate_request" href="#pulpy.system.CoreRequestSource.generate_request">generate_request</a></code></li>
<li><code><a title="pulpy.system.CoreRequestSource.send_request" href="#pulpy.system.CoreRequestSource.send_request">send_request</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pulpy.system.Item" href="#pulpy.system.Item">Item</a></code></h4>
<ul class="">
<li><code><a title="pulpy.system.Item.life_cycle" href="#pulpy.system.Item.life_cycle">life_cycle</a></code></li>
<li><code><a title="pulpy.system.Item.name" href="#pulpy.system.Item.name">name</a></code></li>
<li><code><a title="pulpy.system.Item.size" href="#pulpy.system.Item.size">size</a></code></li>
<li><code><a title="pulpy.system.Item.work" href="#pulpy.system.Item.work">work</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pulpy.system.Job" href="#pulpy.system.Job">Job</a></code></h4>
</li>
<li>
<h4><code><a title="pulpy.system.Monitor" href="#pulpy.system.Monitor">Monitor</a></code></h4>
<ul class="">
<li><code><a title="pulpy.system.Monitor.update" href="#pulpy.system.Monitor.update">update</a></code></li>
<li><code><a title="pulpy.system.Monitor.updatets" href="#pulpy.system.Monitor.updatets">updatets</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pulpy.system.ProbabilityMap" href="#pulpy.system.ProbabilityMap">ProbabilityMap</a></code></h4>
<ul class="">
<li><code><a title="pulpy.system.ProbabilityMap.allocate_weights" href="#pulpy.system.ProbabilityMap.allocate_weights">allocate_weights</a></code></li>
<li><code><a title="pulpy.system.ProbabilityMap.generate_weights" href="#pulpy.system.ProbabilityMap.generate_weights">generate_weights</a></code></li>
<li><code><a title="pulpy.system.ProbabilityMap.get_all_probabilities" href="#pulpy.system.ProbabilityMap.get_all_probabilities">get_all_probabilities</a></code></li>
<li><code><a title="pulpy.system.ProbabilityMap.get_intensity" href="#pulpy.system.ProbabilityMap.get_intensity">get_intensity</a></code></li>
<li><code><a title="pulpy.system.ProbabilityMap.get_map" href="#pulpy.system.ProbabilityMap.get_map">get_map</a></code></li>
<li><code><a title="pulpy.system.ProbabilityMap.get_pop" href="#pulpy.system.ProbabilityMap.get_pop">get_pop</a></code></li>
<li><code><a title="pulpy.system.ProbabilityMap.get_pop_array" href="#pulpy.system.ProbabilityMap.get_pop_array">get_pop_array</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pulpy.system.Report" href="#pulpy.system.Report">Report</a></code></h4>
<ul class="">
<li><code><a title="pulpy.system.Report.value" href="#pulpy.system.Report.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pulpy.system.Request" href="#pulpy.system.Request">Request</a></code></h4>
<ul class="">
<li><code><a title="pulpy.system.Request.estimate_remaining_transfer_time" href="#pulpy.system.Request.estimate_remaining_transfer_time">estimate_remaining_transfer_time</a></code></li>
<li><code><a title="pulpy.system.Request.estimate_time_to_completition" href="#pulpy.system.Request.estimate_time_to_completition">estimate_time_to_completition</a></code></li>
<li><code><a title="pulpy.system.Request.finish" href="#pulpy.system.Request.finish">finish</a></code></li>
<li><code><a title="pulpy.system.Request.is_alive" href="#pulpy.system.Request.is_alive">is_alive</a></code></li>
<li><code><a title="pulpy.system.Request.may_process_size" href="#pulpy.system.Request.may_process_size">may_process_size</a></code></li>
<li><code><a title="pulpy.system.Request.process" href="#pulpy.system.Request.process">process</a></code></li>
<li><code><a title="pulpy.system.Request.start" href="#pulpy.system.Request.start">start</a></code></li>
<li><code><a title="pulpy.system.Request.update_finish_callback" href="#pulpy.system.Request.update_finish_callback">update_finish_callback</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pulpy.system.RequestSource" href="#pulpy.system.RequestSource">RequestSource</a></code></h4>
<ul class="">
<li><code><a title="pulpy.system.RequestSource.generate_request" href="#pulpy.system.RequestSource.generate_request">generate_request</a></code></li>
<li><code><a title="pulpy.system.RequestSource.send_requests" href="#pulpy.system.RequestSource.send_requests">send_requests</a></code></li>
<li><code><a title="pulpy.system.RequestSource.update_probability_map" href="#pulpy.system.RequestSource.update_probability_map">update_probability_map</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pulpy.system.Result" href="#pulpy.system.Result">Result</a></code></h4>
<ul class="">
<li><code><a title="pulpy.system.Result.reason" href="#pulpy.system.Result.reason">reason</a></code></li>
<li><code><a title="pulpy.system.Result.result" href="#pulpy.system.Result.result">result</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pulpy.system.Source" href="#pulpy.system.Source">Source</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>